# u-boot主Makefile分析  

## 版本

```bash
VERSION = 2010
PATCHLEVEL = 03
SUBLEVEL =
EXTRAVERSION =
ifneq "$(SUBLEVEL)" ""
U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
else
U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL)$(EXTRAVERSION)
endif
TIMESTAMP_FILE = $(obj)include/timestamp_autogenerated.h
VERSION_FILE = $(obj)include/version_autogenerated.h
```
- `U_BOOT_VERSION`最终值为`2010.03`
- `$(obj)` obj变量在后面定义了，注意此处使用的是`=`，而不是`:=`  
- 看名字 `timestamp_autogenerated.h`和`version_autogenerated.h`是自动生成的，在实际目录下是找不不到的，只有编译过后才能找到具体的文件  

##   

```bash
HOSTARCH := $(shell uname -m | \
	sed -e s/i.86/i386/ \
	    -e s/sun4u/sparc64/ \
	    -e s/arm.*/arm/ \
	    -e s/sa110/arm/ \
	    -e s/powerpc/ppc/ \
	    -e s/ppc64/ppc/ \
	    -e s/macppc/ppc/)

HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
	    sed -e 's/\(cygwin\).*/cygwin/')
```

- `HOSTARCH`，HOST 是主机，即当前使用的电脑，ARCH 是architecture(架构)缩写，表示CPU架构，则`HOSTARCH`表示主机的 CPU 架构
- `HOSTOS`,即主机的操作系统
- 在shell环境中执行命令`uname -m`获取当前执行此命令的主机CPU的版本号  
- 在shell环境中执行命令`uname -s`获取当前操作系统类型
	- shell中有两种方式  
	```bash
	var=`pwd`
	
	var=$(shell pwd)
	```
- `|`在shell中表示管道，即前面命令的输出做为后面的输入  
- `\`代表行转译，即本行命令未完成
- `sed`命令，Linux sed命令是利用script来处理文本文件。sed可依照script的指令，来处理、编辑文本文件
	- `sed [-hnV][-e<script>][-f<script文件>][文本文件]`  
		`-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。 `  
		`sed 's/要被取代的字串/新的字串/g'`

##  
```bash
# Set shell to bash if possible, otherwise fall back to sh
SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
	else if [ -x /bin/bash ]; then echo /bin/bash; \
	else echo sh; fi; fi)

export HOSTARCH HOSTOS SHELL
```
- `export`为对外部文件变量可见（别的文件也能使用后面的变量）
##  

```
ifeq (,$(findstring s,$(MAKEFLAGS)))
XECHO = echo
else
XECHO = :
endif
```

- 静默编译  
如：  
	`make -s`  
	
	- `MAKEFLAGS`代表命令行输入的参数
	- `findstring s,$(MAKEFLAGS)` ,若`MAKEFLAGS`的值为`s`,则通过ifeq(,)与`空`做比较

## 编译方法    

```bash
ifdef O
ifeq ("$(origin O)", "command line")
BUILD_DIR := $(O)
endif
endif

ifneq ($(BUILD_DIR),)
saved-output := $(BUILD_DIR)

# Attempt to create a output directory.
$(shell [ -d ${BUILD_DIR} ] || mkdir -p ${BUILD_DIR})

# Verify if it was successful.
BUILD_DIR := $(shell cd $(BUILD_DIR) && /bin/pwd)
$(if $(BUILD_DIR),,$(error output directory "$(saved-output)" does not exist))
endif # ifneq ($(BUILD_DIR),)

OBJTREE		:= $(if $(BUILD_DIR),$(BUILD_DIR),$(CURDIR))
SRCTREE		:= $(CURDIR)
TOPDIR		:= $(SRCTREE)
LNDIR		:= $(OBJTREE)
export	TOPDIR SRCTREE OBJTREE

MKCONFIG	:= $(SRCTREE)/mkconfig
export MKCONFIG

ifneq ($(OBJTREE),$(SRCTREE))
REMOTE_BUILD	:= 1
export REMOTE_BUILD
endif

# $(obj) and (src) are defined in config.mk but here in main Makefile
# we also need them before config.mk is included which is the case for
# some targets like unconfig, clean, clobber, distclean, etc.
ifneq ($(OBJTREE),$(SRCTREE))
obj := $(OBJTREE)/
src := $(SRCTREE)/
else
obj :=
src :=
endif
export obj src

# Make sure CDPATH settings don't interfere
unexport CDPATH
```


##### 本地编译
- 即在各个目录当前位置将.c编译成.o文件
##### 指定目录编译
- 即指定特定的目录，将所有的.c编译成.o文件

--- 
此部分代码可以参考`Makefile`文件中程序上方的注释
---

- OBJTREE：编译出的.o文件存放的目录的根目录。在默认编译下，`OBJTREE`等于当前目录；在`o=XX`的变一下，`OBJTREE`等于我们设置的那个输出目录

- SRCTREE：源码目录，即源码的根目录，也就是当前目录
- MKCONFIG：Makefile中定义的一个变量，后面会使用到，他的值就是源码根目录下面的mkconfig脚本，这个脚本就是uboot配置阶段的配置脚本 ，并且使用export作为全局变量 

---
```bash
include $(obj)include/config.mk`
export ARCH CPU BOARD VENDOR SOC
```
- 由上面代码可以发现，当`OBJTREE`和`SRCTREE`值相等时，即两个目录都是一致的(本地编译情况)，`obj`为`空`  
- `ARCH`定义的是当前编译的目标CPU的架构  
- `include/config.mk`这个文件并不是源码自带文件，是在配置过程中(执行make xxxx_conifg)才会生成此文件
- 导出了5个变量作为环境变量，这样导出作为环境变量，目的是可被人容易且集中的配置。配置的地方在主Makefile文件后面  
如：  
```
sbc2410x_config: unconfig
	@$(MKCONFIG) $(@:_config=) arm arm920t sbc2410x NULL s3c24x0
```
---
```
ifeq ($(ARCH),arm)
CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-
endif
```
- 若`ARCH`为`arm`，则设置`CROSS_COMPILE`的路径（此路径为linux主机安装的交叉编译工具链存在的目录和前缀（前缀为：arm-none-linux-gnueabi-）。这个路径只要能保证找到那个交叉编译工具链即可，比一定非得是全路径的，相对路径也可以。如果已经将工具链导出到环境变量，并且设置了符号链接，这样`CROSS_COMPILE=arm-none-linux-gnueabi-`就可以）  

`CROSS_COMPILE`
- 定义交叉编译工具链的前缀，定义前缀是为后面使用（前缀+后缀定义编译过程中用到的各种工具链中的工具）
- 在不同CPU架构上的交叉编译工具链，只是前缀不一样，后缀都是一样的。因此定义时把前缀和后缀分开，只需要在定义前缀时区分各种架构即可实现移植  
- 实际应用时，可以在Makefile中去更改设置`CROSS_COMPILE`的值，也可以在编译时用`make CROSS_COMPILE=XXX`设置，并且编译时传参的方法可以覆盖Makefile里面的设置
如：  
```bash
arm-none-linux-gnueabi-as
arm-none-linux-gnueabi-c++
arm-none-linux-gnueabi-gdb
arm-none-linux-gnueabi-gcc
arm-none-linux-gnueabi-g+++
...
...
```

---
```bash
# load other configuration
include $(TOPDIR)/config.mk
```
- 导入外部的`conifg.mk`脚本
- `TOPDIR`= `SRCTREE`，即源码根目录  