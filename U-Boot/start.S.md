# start.S 分析

---

- 检查复位状态  
- IO 恢复  
- 关看门狗  
- 供电锁存  
- 时钟初始化  
- DDR 初始化  
- 串口初始化  
- tzpc 初始化  

#### 为何整个 uboot 程序的第一个运行的代码是 start.S 文件？  
整个程序入口取决于连接脚本中ENTRY声明的地方:`ENTRY(_start)`。因此`_start`符号所在的文件就是整个程序的起始文件，_start所在处的代码就是整个程序的起始代码。  而在start.S文件中有这样的定义：  
```ASM
.globl _start
_start: b reset
```

---

#### 包含的头文件分析
```C
#include <config.h>
#include <version.h>
#if defined(CONFIG_ENABLE_MMU)
#include <asm/proc/domain.h>
#endif
#if defined(CONFIG_S5PV310)
#include <s5pv310.h>
#endif
#if defined(CONFIG_S5PC210)
#include <s5pc210.h>
#endif

#ifndef CONFIG_ENABLE_MMU
#ifndef CFG_PHY_UBOOT_BASE
#define CFG_PHY_UBOOT_BASE	CFG_UBOOT_BASE
#endif
#endif
```
解析：  
- 本文件开头便引用了`config.h`文件，此文件是根据根目录下的`mkconfig.md`文件末尾生成的。`config.h`文件内容为：  
```C
#define CONFIG_POP_1GDDR
#define CONFIG_BOARDDIR board/samsung/smdkc210
#include <config_defaults.h>
#include <configs/itop_4412_ubuntu.h>
#include <asm/config.h>

```
对于本文件重要的为：`configs/itop_4412_ubuntu.h`，此文件包含了关于移植时的配置信息，多数为宏定义  
- `version.h`文件内容为：  
```C
#ifndef DO_DEPS_ONLY
#include "version_autogenerated.h"
#endif
```
`version_autogenerated.h`文件是根据主 Makefile 文件自动生成的，内容为：`#define U_BOOT_VERSION "U-Boot 2010.03"`，即uboot的版本号，这个文件在其它文件中会被包含。其实uboot其它代码可以直接调用Makefile中的定义的版本信息，但是为了可移植性考虑，搞出了这样的自动生成的文件，绕来绕去
- `asm/proc/domain.h`文件本身是不存在的，准确的说asm目录是不存在的。在根目录下的`mkconfig.md`文件中有详细描述，主要是基于可移植性因素考虑，在uboot配置时会生成asm软连接

---

预备知识：  
`.word`为汇编伪指令，定义四字节的变量，地址即为当前语句出现位置的地址  
```ASM
.word 0x2000
.word 0x0
.word 0x0
.word 0x0
```
- 上面的四行语句共定义了4×4即16个字节空间，第一个位置写入0x2000的值，后面三个位置分别写入0x0的值。在这里预留这16字节的位置，是为了后面计算校验而预先占位的，当前写入的数值不准确，后面程序会重新写入。  
如果我们是usb启动直接下载的方式启动的则不需要16字节校验头（irom application note）；2、如果是SD卡启动则会给原镜像前加16字节的校验头（即此处预留的16个字节）。

```ASM
.globl _start
_start: b	reset
	ldr	pc, _undefined_instruction
	ldr	pc, _software_interrupt
	ldr	pc, _prefetch_abort
	ldr	pc, _data_abort
	ldr	pc, _not_used
	ldr	pc, _irq
	ldr	pc, _fiq
```
解析：  
- 在uboot代码编译链接时，在U-boot.lds文件中就已经定义了`ENTRY(_start)`为整个代码的入口，上面代码`.globl _start`声明定义了`_start`为全局变量，代表uboot在启动的时候，程序是从这个位置开始运行的
- 上面的这段代码定义了程序的中断向量表，在程序运行的一开始便定义，这是根据soc手册描述来进行的，硬性规定就得这么做。此处只是按手册规定的顺序占位定义跳转的变量，后面定义具体的代码
- `.balignl 16,0xdeadbeef`这条指令目的是使当前地址对齐排布，若当前地址不对齐，则自动向后走直到地址对齐，并且向后走的这段内存使用 0xdeadbeff 来填充。此处填充的0xdeadbeff并无实际意义，使用0填充也可。地址对齐目的是效率或硬件方面的要求

```ASM
_TEXT_BASE:
	.word	TEXT_BASE
```
```ASM
_TEXT_PHY_BASE:
	.word	CFG_PHY_UBOOT_BASE
```
解析：  
- `TEXT_BASE`在`board/samsung/smdkc210`目录下的config.mk中定义，是在配置过程中生成的。是我们链接时指定的 uboot 链接地址，内容为：`TEXT_BASE = 0xc3e00000`
- `CFG_PHY_UBOOT_BASE`在`configs/itop_4412_ubuntu.h`中定义的（本文件开头包含的头文件），是uboot在DDR中的物理地址，内容为`#define CFG_PHY_UBOOT_BASE	MEMORY_BASE_ADDRESS + 0x3e00000`，即 CFG_PHY_UBOOT_BASE = 0x40000000 + 0x3e00000 = 0x43e00000

```ASM
.globl _armboot_start
_armboot_start: 
	.word _start
```

```ASM
.globl _bss_start
_bss_start:
	.word __bss_start

.globl _bss_end
_bss_end:
	.word _end
```
解析：  
- `__bss_start`和 `_end`是在`u-boot.lds`文件中定义的，在清段信息时会使用到

```ASM
#if defined(CONFIG_USE_IRQ)
/* IRQ stack memory (calculated at run-time) */
.globl IRQ_STACK_START
IRQ_STACK_START:
	.word	0x0badc0de

/* IRQ stack memory (calculated at run-time) */
.globl FIQ_STACK_START
FIQ_STACK_START:
	.word 0x0badc0de
#endif
```
- 在uboot中实际很少使用到中断，上面的代码实际是并未使用的，即：`CONFIG_USE_IRQ`这个宏是没有定义的  

```ASM
reset:
#if 0
	/*
	 * set the cpu to SVC32 mode and IRQ & FIQ disable
	 */
	mrs	r0, cpsr
	bic	r0, r0, #0x3f
	orr	r0, r0, #0xd3
	msr	cpsr, r0
#else//*****ly
	mrs	r0, cpsr
	bic	r0, r0, #0x1f
	orr	r0, r0, #0xd3
	msr	cpsr,r0
#endif
```
解析：  
预备知识：  
- MRS指令的格式为：
MRS{条件} 通用寄存器，程序状态寄存器（CPSR或SPSR）  
MRS指令用于将程序状态寄存器的内容传送到通用寄存器中
- MSR指令的格式为：
MSR{条件} 程序状态寄存器（CPSR或SPSR）_<域>，操作数  
MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中
- BIC指令的格式为：
BIC{条件}{S} 目的寄存器，操作数1，操作数2  
BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中  
```ASM
bic r0,r0,#0x1f  
0x1f = 11111b  
其含义：清除r0的bit[4:0]位
```
- ORR指令的格式为：  
ORR{条件}{S}  目的寄存器，操作数1，操作数2  
ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中  
```ASM
orr r0,r0,#0xd3
```
0xd3=1101 0111
 将r0与0xd3作算数或运算，然后将结果返还给r0,即把r0的bit[7:6]和bit[4]和bit[2:0]置为1
- 上面代码实际执行的是 else 中的程序，将cpsr寄存器中的模式位设置为管理模式（SVC模式），禁止FIQ、IRQ中断，工作状态位设置为ARM  
###注意###

此部分代码为整个 uboot 程序最一开始执行的位置，因为上电(冷上电)也是一种复位，都会执行整个复位代码
```ASM
#if 1 //*****ly
cache_init:
	mrc	p15, 0, r0, c0, c0, 0	@ read main ID register
	and	r1, r0, #0x00f00000	@ variant
	and	r2, r0, #0x0000000f	@ revision
	orr	r2, r2, r1, lsr #20-4	@ combine variant and revision
	cmp	r2, #0x30
	mrceq	p15, 0, r0, c1, c0, 1	@ read ACTLR
	orreq	r0, r0, #0x6		@ Enable DP1(2), DP2(1)
	mcreq	p15, 0, r0, c1, c0, 1	@ write ACTLR
	/*
	 * Invalidate L1 I/D
	 */
	mov	r0, #0			@ set up for MCR
	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
	orr	r0, r0, #0x00001000	@ set bit 12 (---I) Icache
	orr	r0, r0, #0x00000002	@ set bit 1  (--A-) Align
	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
	mcr	p15, 0, r0, c1, c0, 0
#endif
```
- 上面包含两部分，cache配置以及关闭MMU，一般了解即可  

```ASM
ldr	r0, =POWER_BASE
ldr	r1, [r0,#OMR_OFFSET]
bic	r2, r1, #0xffffffc1
```
- 读取boot信息，即从哪里启动是读取外部GPIO引脚：OM5-OM0的引脚电平信息判断  
实际上在210内部有一个寄存器（地址是 0xE0000004），这个寄存器中的值是硬件根据OM引脚的设置而自动设置值的。这个值反映的就是OM引脚的接法（电平高低），也就是真正的启动介质是谁。
我们代码中可以通过读取这个寄存器的值然后判断其值来确定当前选中的启动介质是Nand还是SD还是其他的。读取出寄存器的值并将其它无关位清0，将最终数值存入 r2 寄存器  
- `POWER_BASE`为 0x10020000  
`OMR_OFFSET`为 0x0  

```ASM
/* SD/MMC BOOT */
cmp     r2, #0x4
moveq   r3, #BOOT_MMCSD	

/* eMMC4.3 BOOT */
cmp		r2, #0x6
moveq	r3, #BOOT_EMMC43

/* eMMC441 BOOT */
cmp		r2, #0x28
moveq	r3, #BOOT_EMMC441
```
- 通过上面判断出的启动方式（r2值），在此部分代码分析是哪种启动方式，由此可知，若 r2 = 0x04(SD/MMC启动方式)，r2 = 0x06(eMMC4.3启动方式)，r2 = 0x28(eMMC441启动方式)，并且将启动方式更新到 r3 寄存器中备用  

---

`bl	lowlevel_init	/* go setup pll,mux,memory */`调用 lowlevel_init  
- 注意，在这个调用之前，本文件并未对栈进行初始化，并未给 sp 指定栈内存地址。  而是在这条语句之后对 sp 指定了栈内存地址  
因为 `bl` 指令跳转到`lowlevel_init`文件中，使用 lr 只保存一次返回地址，若没有对栈进行初始化，在`lowlevel_init.S`中若有跳转，则会丢失前面一次保存的返回地址。 在本 uboot 代码中，在 lowlevel_init 文件中的开始部分定义了 sp 栈地址 

```
ldr	r0, =0x1002330C  /* PS_HOLD_CONTROL register */
ldr	r1, =0x00005300	 /* PS_HOLD output high	*/
str	r1, [r0]
```
- PS 供电锁存，这个操作已经在`lowlevel_init.S`中定义了，其实完全可以将这三行删除，两次操作也不会有任何影响  

```
	/* get ready to call C functions */
	ldr	sp, _TEXT_PHY_BASE	/* setup temp stack pointer */
	sub	sp, sp, #12
	mov	fp, #0			/* no previous frame, so fp=0 */
```
- 栈设置：这是第二次设置 sp 栈地址，第一次是在`lowlevel_init.S`开头部分定义的，第一次将栈设置在 SRAM 中，在本次，将栈设置到了 DDR 中(从上面描述可知为：0x43e00000)  
再次配置栈的目的：此时 DDR 已经初始化，并且可以用，完全可以将栈设置到 DDR 中使用，并且在 SRAM 中空间是有限的，若溢出，并不安全

```ASM
	/* when we already run in ram, we don't need to relocate U-Boot.
	 * and actually, memory controller must be configured before U-Boot
	 * is running in ram.
	 */
	ldr	r0, =0xff000fff
	bic	r1, pc, r0		/* r0 <- current base addr of code */
	ldr	r2, _TEXT_BASE	/* r1 <- original base addr in ram */
	bic	r2, r2, r0		/* r0 <- current base addr of code */
	cmp     r1, r2      /* compare r0, r1                  */
	beq     after_copy  /* r0 == r1 then skip flash copy   */
```
- 判断代码是否需要重定位，即程序是在哪里执行。再次使用相同的代码判断（上次是在`lowlevel_init.S`中判断是否为冷启动，若为冷启动，则需要初始化时钟和 DDR）
- 若为冷启动情况，即 r1 和 r2 相等，则执行`after_copy`进行重定位操作，将 uboot 程序加载到 DDR 的链接地址中（CFG_PHY_UBOOT_BASE = 0x43e00000）  

---