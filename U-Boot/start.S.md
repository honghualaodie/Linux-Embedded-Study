# start.S 分析

---

- 检查复位状态  
- IO 恢复  
- 关看门狗  
- 供电锁存  
- 时钟初始化  
- DDR 初始化  
- 串口初始化  
- tzpc 初始化  

#### 为何整个 uboot 程序的第一个运行的代码是 start.S 文件？  
整个程序入口取决于连接脚本中ENTRY声明的地方:`ENTRY(_start)`。因此`_start`符号所在的文件就是整个程序的起始文件，_start所在处的代码就是整个程序的起始代码。  而在start.S文件中有这样的定义：  
```ASM
.globl _start
_start: b reset
```

---

#### 包含的头文件分析
```C
#include <config.h>
#include <version.h>
#if defined(CONFIG_ENABLE_MMU)
#include <asm/proc/domain.h>
#endif
#if defined(CONFIG_S5PV310)
#include <s5pv310.h>
#endif
#if defined(CONFIG_S5PC210)
#include <s5pc210.h>
#endif

#ifndef CONFIG_ENABLE_MMU
#ifndef CFG_PHY_UBOOT_BASE
#define CFG_PHY_UBOOT_BASE	CFG_UBOOT_BASE
#endif
#endif
```
解析：  
- 本文件开头便引用了`config.h`文件，此文件是根据根目录下的`mkconfig.md`文件末尾生成的。`config.h`文件内容为：  
```C
#define CONFIG_POP_1GDDR
#define CONFIG_BOARDDIR board/samsung/smdkc210
#include <config_defaults.h>
#include <configs/itop_4412_ubuntu.h>
#include <asm/config.h>

```
对于本文件重要的为：`configs/itop_4412_ubuntu.h`，此文件包含了关于移植时的配置信息，多数为宏定义  
- `version.h`文件内容为：  
```C
#ifndef DO_DEPS_ONLY
#include "version_autogenerated.h"
#endif
```
`version_autogenerated.h`文件是根据主 Makefile 文件自动生成的，内容为：`#define U_BOOT_VERSION "U-Boot 2010.03"`，即uboot的版本号，这个文件在其它文件中会被包含。其实uboot其它代码可以直接调用Makefile中的定义的版本信息，但是为了可移植性考虑，搞出了这样的自动生成的文件，绕来绕去
- `asm/proc/domain.h`文件本身是不存在的，准确的说asm目录是不存在的。在根目录下的`mkconfig.md`文件中有详细描述，主要是基于可移植性因素考虑，在uboot配置时会生成asm软连接

---

预备知识：  
`.word`为汇编伪指令，定义四字节的变量，地址即为当前语句出现位置的地址  
```ASM
.word 0x2000
.word 0x0
.word 0x0
.word 0x0
```
- 上面的四行语句共定义了4×4即16个字节空间，第一个位置写入0x2000的值，后面三个位置分别写入0x0的值。在这里预留这16字节的位置，是为了后面计算校验而预先占位的，当前写入的数值不准确，后面程序会重新写入。  
如果我们是usb启动直接下载的方式启动的则不需要16字节校验头（irom application note）；2、如果是SD卡启动则会给原镜像前加16字节的校验头（即此处预留的16个字节）。

```ASM
.globl _start
_start: b	reset
	ldr	pc, _undefined_instruction
	ldr	pc, _software_interrupt
	ldr	pc, _prefetch_abort
	ldr	pc, _data_abort
	ldr	pc, _not_used
	ldr	pc, _irq
	ldr	pc, _fiq
```
解析：  
- 在uboot代码编译链接时，在U-boot.lds文件中就已经定义了`ENTRY(_start)`为整个代码的入口，上面代码`.globl _start`声明定义了`_start`为全局变量，代表uboot在启动的时候，程序是从这个位置开始运行的
- 上面的这段代码定义了程序的中断向量表，在程序运行的一开始便定义，这是根据soc手册描述来进行的，硬性规定就得这么做。此处只是按手册规定的顺序占位定义跳转的变量，后面定义具体的代码
- `.balignl 16,0xdeadbeef`这条指令目的是使当前地址对齐排布，若当前地址不对齐，则自动向后走直到地址对齐，并且向后走的这段内存使用 0xdeadbeff 来填充。此处填充的0xdeadbeff并无实际意义，使用0填充也可。地址对齐目的是效率或硬件方面的要求

```ASM
_TEXT_BASE:
	.word	TEXT_BASE
```
```ASM
_TEXT_PHY_BASE:
	.word	CFG_PHY_UBOOT_BASE
```
解析：  
- `TEXT_BASE`在`board/samsung/smdkc210`目录下的config.mk中定义，是在配置过程中生成的。是我们链接时指定的 uboot 链接地址，内容为：`TEXT_BASE = 0xc3e00000`
- `CFG_PHY_UBOOT_BASE`在`configs/itop_4412_ubuntu.h`中定义的（本文件开头包含的头文件），是uboot在DDR中的物理地址，内容为`#define CFG_PHY_UBOOT_BASE	MEMORY_BASE_ADDRESS + 0x3e00000`，即 CFG_PHY_UBOOT_BASE = 0x40000000 + 0x3e00000 = 0x43e00000

```ASM
.globl _armboot_start
_armboot_start: 
	.word _start
```

```ASM
.globl _bss_start
_bss_start:
	.word __bss_start

.globl _bss_end
_bss_end:
	.word _end
```
解析：  
- `__bss_start`和 `_end`是在`u-boot.lds`文件中定义的，在清段信息时会使用到

```ASM
#if defined(CONFIG_USE_IRQ)
/* IRQ stack memory (calculated at run-time) */
.globl IRQ_STACK_START
IRQ_STACK_START:
	.word	0x0badc0de

/* IRQ stack memory (calculated at run-time) */
.globl FIQ_STACK_START
FIQ_STACK_START:
	.word 0x0badc0de
#endif
```
- 在uboot中实际很少使用到中断，上面的代码实际是并未使用的，即：`CONFIG_USE_IRQ`这个宏是没有定义的  

```ASM
reset:
#if 0
	/*
	 * set the cpu to SVC32 mode and IRQ & FIQ disable
	 */
	mrs	r0, cpsr
	bic	r0, r0, #0x3f
	orr	r0, r0, #0xd3
	msr	cpsr, r0
#else//*****ly
	mrs	r0, cpsr
	bic	r0, r0, #0x1f
	orr	r0, r0, #0xd3
	msr	cpsr,r0
#endif
```
解析：  
预备知识：  
- MRS指令的格式为：
MRS{条件} 通用寄存器，程序状态寄存器（CPSR或SPSR）  
MRS指令用于将程序状态寄存器的内容传送到通用寄存器中
- MSR指令的格式为：
MSR{条件} 程序状态寄存器（CPSR或SPSR）_<域>，操作数  
MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中
- BIC指令的格式为：
BIC{条件}{S} 目的寄存器，操作数1，操作数2  
BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中  
```ASM
bic r0,r0,#0x1f  
0x1f = 11111b  
其含义：清除r0的bit[4:0]位
```
- ORR指令的格式为：  
ORR{条件}{S}  目的寄存器，操作数1，操作数2  
ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中  
```ASM
orr r0,r0,#0xd3
```
0xd3=1101 0111
 将r0与0xd3作算数或运算，然后将结果返还给r0,即把r0的bit[7:6]和bit[4]和bit[2:0]置为1
- 上面代码实际执行的是 else 中的程序，将cpsr寄存器中的模式位设置为管理模式（SVC模式），禁止FIQ、IRQ中断，工作状态位设置为ARM  
###注意###

此部分代码为整个 uboot 程序最一开始执行的位置，因为上电(冷上电)也是一种复位，都会执行整个复位代码
```ASM
#if 1 //*****ly
cache_init:
	mrc	p15, 0, r0, c0, c0, 0	@ read main ID register
	and	r1, r0, #0x00f00000	@ variant
	and	r2, r0, #0x0000000f	@ revision
	orr	r2, r2, r1, lsr #20-4	@ combine variant and revision
	cmp	r2, #0x30
	mrceq	p15, 0, r0, c1, c0, 1	@ read ACTLR
	orreq	r0, r0, #0x6		@ Enable DP1(2), DP2(1)
	mcreq	p15, 0, r0, c1, c0, 1	@ write ACTLR
	/*
	 * Invalidate L1 I/D
	 */
	mov	r0, #0			@ set up for MCR
	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
	orr	r0, r0, #0x00001000	@ set bit 12 (---I) Icache
	orr	r0, r0, #0x00000002	@ set bit 1  (--A-) Align
	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
	mcr	p15, 0, r0, c1, c0, 0
#endif
```
- 上面包含两部分，cache配置以及关闭MMU，一般了解即可  

```ASM
ldr	r0, =POWER_BASE
ldr	r1, [r0,#OMR_OFFSET]
bic	r2, r1, #0xffffffc1
```
- 读取boot信息，即从哪里启动是读取外部GPIO引脚：OM5-OM0的引脚电平信息判断  
实际上在210内部有一个寄存器（地址是 0xE0000004），这个寄存器中的值是硬件根据OM引脚的设置而自动设置值的。这个值反映的就是OM引脚的接法（电平高低），也就是真正的启动介质是谁。
我们代码中可以通过读取这个寄存器的值然后判断其值来确定当前选中的启动介质是Nand还是SD还是其他的。读取出寄存器的值并将其它无关位清0，将最终数值存入 r2 寄存器  
- `POWER_BASE`为 0x10020000  
`OMR_OFFSET`为 0x0  

```ASM
/* SD/MMC BOOT */
cmp     r2, #0x4
moveq   r3, #BOOT_MMCSD	

/* eMMC4.3 BOOT */
cmp		r2, #0x6
moveq	r3, #BOOT_EMMC43

/* eMMC441 BOOT */
cmp		r2, #0x28
moveq	r3, #BOOT_EMMC441

ldr	r0, =INF_REG_BASE
str	r3, [r0, #INF_REG3_OFFSET] 
```
- 通过上面判断出的启动方式（r2值），在此部分代码分析是哪种启动方式，由此可知，若 r2 = 0x04(SD/MMC启动方式)，r2 = 0x06(eMMC4.3启动方式)，r2 = 0x28(eMMC441启动方式)，并且将启动方式更新到 r3 寄存器中，并且将 r3 值写入到`INF_REG_BASE + INF_REG3_OFFSET`地址处备用  

---

`bl	lowlevel_init	/* go setup pll,mux,memory */`调用 lowlevel_init  
- 注意，在这个调用之前，本文件并未对栈进行初始化，并未给 sp 指定栈内存地址。  而是在这条语句之后对 sp 指定了栈内存地址  
因为 `bl` 指令跳转到`lowlevel_init`文件中，使用 lr 只保存一次返回地址，若没有对栈进行初始化，在`lowlevel_init.S`中若有跳转，则会丢失前面一次保存的返回地址。 在本 uboot 代码中，在 lowlevel_init 文件中的开始部分定义了 sp 栈地址 

```
ldr	r0, =0x1002330C  /* PS_HOLD_CONTROL register */
ldr	r1, =0x00005300	 /* PS_HOLD output high	*/
str	r1, [r0]
```
- PS 供电锁存，这个操作已经在`lowlevel_init.S`中定义了，其实完全可以将这三行删除，两次操作也不会有任何影响  

```
/* get ready to call C functions */
ldr	sp, _TEXT_PHY_BASE	/* setup temp stack pointer */
sub	sp, sp, #12
mov	fp, #0			    /* no previous frame, so fp=0 */
```
- 栈设置：这是第二次设置 sp 栈地址，第一次是在`lowlevel_init.S`开头部分定义的，第一次将栈设置在 SRAM 中，在本次，将栈设置到了 DDR 中(从上面描述可知为：0x43e00000)  
再次配置栈的目的：此时 DDR 已经初始化，并且可以用，完全可以将栈设置到 DDR 中使用，并且在 SRAM 中空间是有限的，若溢出，并不安全

```ASM
/* when we already run in ram, we don't need to relocate U-Boot.
 * and actually, memory controller must be configured before U-Boot
 * is running in ram.
 */
ldr	r0, =0xff000fff
bic	r1, pc, r0		/* r0 <- current base addr of code */
ldr	r2, _TEXT_BASE	/* r1 <- original base addr in ram */
bic	r2, r2, r0		/* r0 <- current base addr of code */
cmp r1, r2      /* compare r0, r1                  */
beq after_copy  /* r0 == r1 then skip flash copy   */
```
- 判断代码是否需要重定位，即程序是在哪里执行。再次使用相同的代码判断（上次是在`lowlevel_init.S`中判断是否为冷启动，若为冷启动，则需要初始化时钟和 DDR）
- 若为冷启动情况，即 r1 和 r2 不相等，即代表设备并非冷启动，则执行`after_copy`进行虚拟地址映射  

---

#### 代码重定位  
```ASM
ldr  r0, =INF_REG_BASE
ldr	 r1, [r0, #INF_REG3_OFFSET]
cmp	 r1, #BOOT_NAND		/* 0x0 => boot device is nand */
beq  nand_boot

cmp	 r1, #BOOT_ONENAND	/* 0x1 => boot device is onenand */
beq	 onenand_boot

cmp  r1, #BOOT_EMMC441
beq  emmc441_boot

cmp  r1, #BOOT_EMMC43
beq  emmc_boot

cmp  r1, #BOOT_MMCSD
beq  mmcsd_boot

cmp  r1, #BOOT_NOR
beq  nor_boot

cmp  r1, #BOOT_SEC_DEV
beq  mmcsd_boot
```

上面的代码已经通过读取外部 OM 引脚判断确定了是从哪里启动（EMMC、NOR、OneNAND...？）,并且将启动方式判断码保存到了`INF_REG_BASE + INF_REG3_OFFSET`  
通过头两句，将保存的启动码从`INF_REG_BASE + INF_REG3_OFFSET`处读出到 r1 寄存器，并且判断是哪种启动方式，若匹配成功则跳转  
如：  
若通过上面的读取 OM 引脚判断是从 SD 卡启动，则在`INF_REG_BASE + INF_REG3_OFFSET`地址处保存有`BOOT_MMCSD`，即 0x6，在本段代码中读取此地址，与杜英标号判断，则匹配到并执行`mmcsd_boot`

```ASM
mmcsd_boot:
#ifdef CONFIG_CLK_1000_400_200
	ldr	r0, =CMU_BASE
	ldr	r2, =CLK_DIV_FSYS2_OFFSET
	ldr	r1, [r0, r2]
	orr r1, r1, #0xf
	str r1, [r0, r2]
#endif
	bl movi_uboot_copy
	b  after_copy
```
- 主要的重定位代码是在`movi_uboot_copy`中  

```C
void movi_uboot_copy(void)
{
#ifdef CONFIG_EVT1
	copy_sd_mmc_to_mem copy_bl2 = (copy_sd_mmc_to_mem)*(u32 *)(0x02020030);
#else
	copy_sd_mmc_to_mem copy_bl2 = (copy_sd_mmc_to_mem)(0x00002488);
#endif
#if defined(CONFIG_SECURE)
	copy_bl2(MOVI_UBOOT_POS, MOVI_UBOOT_BLKCNT, CFG_PHY_UBOOT_BASE);
#else
	copy_bl2(MOVI_UBOOT_POS, MOVI_UBOOT_BLKCNT, CFG_PHY_UBOOT_BASE);//mj
#endif
}
```
- 代码路径在`cpu/arm_cortexa9/s5pc210`中的 movi.c 中
- 待研究

```ASM
after_copy:

#if defined(CONFIG_ENABLE_MMU)
enable_mmu:
	/* enable domain access */
	ldr	r5, =0x0000ffff
	mcr	p15, 0, r5, c3, c0, 0		@load domain access register

	/* Set the TTB register */
	ldr	r0, _mmu_table_base
	ldr	r1, =CFG_PHY_UBOOT_BASE
	ldr	r2, =0xfff00000
	bic	r0, r0, r2
	orr	r1, r0, r1
	mcr	p15, 0, r1, c2, c0, 0

	/* Enable the MMU */
mmu_on:
	mrc	p15, 0, r0, c1, c0, 0
	orr	r0, r0, #1
	mcr	p15, 0, r0, c1, c0, 0
	nop
	nop
	nop
	nop
#endif
```
准备知识：  
使能域访问（cp15的c3寄存器）  
1)cp15协处理器内部有c0到c15共16个寄存器，这些寄存器每一个都有自己的作用。我们通过mrc和mcr指令来访问这些寄存器。所谓的操作cp协处理器其实就是操作cp15的这些寄存器  
2)c3寄存器在mmu中的作用是控制域访问。域访问是和MMU的访问控制有关的

- `CONFIG_ENABLE_MMU`宏是在`include\configs\itop_4412_ubuntu.h`中定义
- [虚拟地址映射][虚拟地址]
- ![CP15_C3][CP15_C3]  
在CP15的C3寄存器中，划分了16个域，每个区域由两位构成，这两位说明了当前内存的检查权限：  
00：当前级别下，该内存区域不允许被访问，任何的访问都会引起一个domain fault，这时AP位无效  
01：当前级别下，该内存区域的访问必须配合该内存区域的段描述符中AP位进行权检查  
10：保留状态（我们最好不要填写该值，以免引起不能确定的问题）
11：当前级别下，对该内存区域的访问都不进行权限检查。这时AP位无效  
所以只有当相应域的编码为01时，才会根据AP位和协处理器CP15中的C1寄存器的R，S位进行权限检查  
- ![CP15_C2][CP15_C2]  
TTB 是转换表的基地址，转换表是建立一套虚拟地址映射的关键。转换表分2部分，表索引和表项。表索引对应虚拟地址，表项对应物理地址。一对表索引和表项构成一个转换表单元，能够对一个内存块进行虚拟地址转换。（映射中基本规定中规定了内存映射和管理是以块为单位的，至于块有多大，要看你的MMU的支持和你自己的选择。在ARM中支持3种块大小，细表1KB、粗表4KB、段1MB）。真正的转换表就是由若干个转换表单元构成的，每个单元负责1个内存块，总体的转换表负责整个内存空间（0-4G）的映射。整个建立虚拟地址映射的主要工作就是建立这张转换表。转换表放置在内存中的，放置时要求起始地址在内存中要xx位对齐。转换表不需要软件去干涉使用，而是将基地址TTB设置到cp15的c2寄存器中，然后MMU工作时会自动去查转换表  
宏观上理解转换表：整个转换表可以看作是一个int类型的数组，数组中的一个元素就是一个表索引和表项的单元。数组中的元素值就是表项，这个元素的数组下标就是表索引  
`_mmu_table_base`指向的代码在 board\samsung\smdkc210 目录下的 lowlevel_init_POP.S 中定义。ARM的段式映射中长度为1MB，因此一个映射单元只能管1MB内存，那我们整个4G范围内需要4G/1MB=4096个映射单元，也就是说这个数组的元素个数是4096.实际上我们做的时候并没有依次单个处理这4096个单元，而是把4096个分成几部分，然后每部分用for循环做相同的处理  
- ![CP15_C1][CP15_C1]  
MMU就是memory management unit，内存管理单元。MMU实际上是SOC中一个硬件单元，它的主要功能就是实现虚拟地址到物理地址的映射  
MMU单片在CP15协处理器中进行控制，也就是说要操控MMU进行虚拟地址映射，方法就是对cp15协处理器的寄存器进行编程  

```ASM
/* Set up the stack	*/
stack_setup:
#if defined(CONFIG_MEMORY_UPPER_CODE)
	ldr	sp, =(CFG_UBOOT_BASE + CFG_UBOOT_SIZE - 0x1000)
#else
	ldr	r0, _TEXT_BASE		            /* upper 128 KiB: relocated uboot   */
	sub	r0, r0, #CONFIG_SYS_MALLOC_LEN	/* malloc area                      */
	sub	r0, r0, #CFG_GBL_DATA_SIZE      /* bdinfo                           */
```
- (1)这是第三次设置栈。这次设置栈还是将 sp 在DDR中，之前虽然已经在DDR中设置过一次栈了，但是本次设置栈的目的是将栈放在比较合适（安全，紧凑而不浪费内存）的地方  
(2)我们实际将栈设置在uboot起始地址上方 2MB 处，这样安全的栈空间是：2MB-uboot 大小-0x1000=1.8MB左右。这个空间既没有太浪费内存，又足够安全。

```ASM
clear_bss:
	ldr	r0, _bss_start		/* find start of bss segment  */
	ldr	r1, _bss_end		/* stop here                  */
	mov r2, #0x00000000		/* clear                      */

clbss_l:
	str	r2, [r0]		   /* clear loop...               */
	add	r0, r0, #4
	cmp	r0, r1
	ble	clbss_l
	
	ldr	pc, _start_armboot

_start_armboot:
	.word start_armboot
```
- `_bss_start`和`_bss_end`是在`u-boot.lds`中定义的。目的是清理 bss 段代码  
- `start_armboot`则直接跳转到启动的第二阶段




[虚拟地址]:https://blog.csdn.net/qq_34127958/article/details/72634164  
 
[CP15_C1]: U-Boot/images/CP15_C1.jpg
[CP15_C2]: U-Boot/images/CP15_C2.jpg
[CP15_C3]: U-Boot/images/CP15_C3.jpg
